{
parserClass="com.demo.parser.PurescriptParser"

extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

psiClassPrefix="Purescript"
psiImplClassSuffix="Impl"
psiPackage="com.demo.psi"
psiImplPackage="com.demo.psi.impl"

elementTypeHolderClass="com.demo.psi.PurescriptTypes"
elementTypeClass="com.demo.psi.PurescriptElementType"
tokenTypeClass="com.demo.psi.PurescriptTokenType"

psiImplUtilClass="com.demo.psi.impl.PurescriptPsiImplUtil"

elementTypePrefix="PS_"

tokens = [
line_comment = "regexp:--.*[\r\n]"       // ("--"[^\r\n]*)
EQUAL = "="          // Order matters. Needs to be before VARSYM since dupe
DOUBLE_LEFT_ARROW = "<="   // Order matters. // FIXME Disambiguate from less-than-or-equal-to
DOUBLE_RIGHT_ARROW = "=>"
RIGHT_ARROW = "->"
LEFT_ARROW = "<-"
MODULEID = "regexp:module[ ]+"

//LARGE = "regexp:[A-Z]"
//SMALL = "regexp:[a-z_]"
CONID = "regexp:[A-Z]{1}[A-Za-z_0-9]*" // Starts with cap
DOT = "."
WHEREID = "regexp:where[ ]*[\r\n]+"
WHITE_SPACE = "regexp:[ ]+"      // This works without explicitly being in bnf(?!)
LEFT_PAREN = "("
RIGHT_PAREN = ")"
LEFT_BRACE = "{"
RIGHT_BRACE = "}"
LEFT_BRACKET = "["
RIGHT_BRACKET = "]"


COMMA = ","
VARID = "regexp:[a-z]{1}[A-Za-z_0-9']*" // Starts with lowercase

NEWLINE ="regexp:\n|\r|\r\n"
IMPORTID = "regexp:import[ ]+"  // TODO - Change all tokens with suffix?
FOREIGNID = "regexp:foreign import[ ]+"
TYPEID = "regexp:type[ ]+"
COLON_COLON = "regexp:::[ ]+"
DATAID = "regexp:data[ ]+"
VERTICAL_BAR = "regexp:\|[ ]+"  // FIXME - Space req'd?
NEWTYPEID = "regexp:newtype[ ]+"
CLASSID = "regexp:class[ ]+"
FORALLID = "regexp:forall[ ]+"
INSTANCEID = "regexp:instance[ ]+"
INTEGER = "regexp:[0-9]+"
DECIMAL = "regexp:[0-9]+\.[0-9]+"
STRING = "regexp:\".*?\""
LETID = "regexp:let[ ]+"
INID = "regexp:in[ ]+"
IFID = "regexp:if[ ]+"
THENID = "regexp:then[ ]+"
ELSEID = "regexp:else[ ]+"
CASEID = "regexp:case[ ]+"
OFID = "regexp:[ ]+of"   // May or may not be space at the EOL; find with space before
DOID = "regexp:[ ]+do"  // May or may not be space at EOL; find with space before
INFIX = "regexp:infix[ ]+"
INFIXL = "regexp:infixl[ ]+"
INFIXR = "regexp:infixr[ ]+"
MINUS = "-"
ATSYM = "@"
QUALIFIEDID = "regexp:qualified[ ]+"
//ASID = "regexp:as[ ]+"   // FIXME - this may cause conflicts with var names
DOLLAR = "regexp:[ ]+\$[ ]+"
BACKTICK = "`"

UNDERSCORE = "_"  // This is reserved in the Report
BACKSLASH = "regexp:\\"
VARSYM = "regexp:[/=><+@\|~!#\$%\-\*\?\^\.:&]+" // List from plugin


]

}

module_declaration ::= onl MODULEID modid onl (onl exports)? onl WHEREID onl body

private body ::= impdecls topdecls

exports ::= LEFT_PAREN onl export (onl COMMA? onl export onl)* onl COMMA? onl RIGHT_PAREN
export ::= export1 | export2 | export3 | export4
export1 ::= qvar
//FIXME Constructor without parens not allowed in Purescript?
export2 ::= qcon onl (dot_dot_parens | LEFT_PAREN onl (cname onl (onl COMMA onl cname)*)? onl RIGHT_PAREN)?
export3 ::= MODULEID modid
export4 ::= slash_slash_parens


impdecls ::= (impdecl onl)*
// FIXME - 'as' is not reserved
impdecl ::= IMPORTID QUALIFIEDID? modid ("as" modid)* impspec*
// FIXME - Not sure line breaks supported in Purescript
impspec ::= LEFT_PAREN onl import (onl COMMA? onl import onl)* onl COMMA? onl RIGHT_PAREN
import ::= import1 | import2
import1 ::= var
import2 ::= qcon onl (dot_dot_parens | LEFT_PAREN onl (cname onl (onl COMMA onl cname)*)? onl RIGHT_PAREN)?


topdecls ::= (topdecl onl)*
topdecl ::= typedecl | datadecl | newtypedecl | classdecl | instancedecl | decls | forimpdecl

typedecl ::= TYPEID simpletype EQUAL (type | rec_constr)

datadecl ::= DATAID simpletype onl EQUAL onl constrs

newtypedecl ::= NEWTYPEID simpletype EQUAL newtypeconstr

forimpdecl ::= FOREIGNID DATAID? decl

decls ::= decl+
decl ::= gendecl | funlhs funrhs
gendecl ::= typesigdecl | fixity INTEGER? ops
fixity ::= INFIXL | INFIXR | INFIX
ops ::= op
op ::= varop  // TODO | conop
varop ::= BACKSLASH BACKSLASH | VARSYM | BACKTICK vars BACKTICK




// 4.3.1
// FIXME plugin has qualified con & var; Report does not
// FIXME Purescript has multiple params, in context as well
// Purescript has Nullary Type Class
classdecl ::= CLASSID (scontext DOUBLE_LEFT_ARROW)* con (var)*  (WHEREID cdecls)*
// TODO - add optional newlines
scontext ::= simpleclass | LEFT_PAREN simpleclass (COMMA simpleclass)* RIGHT_PAREN
simpleclass ::= qcon qvar+   //FIXME qcon+ in plugin
cdecls ::= (cdecl onl)+
cdecl ::= typesigdecl   // FIXME gendecl in Report, includes fixity, cdecl includes function def
context ::= LEFT_PAREN clazz (COMMA clazz)* RIGHT_PAREN
clazz ::= qcon vars+ | qcon LEFT_PAREN tyvar atype+ RIGHT_PAREN

typesigdecl ::= typesiglhs COLON_COLON quantifier? (context DOUBLE_RIGHT_ARROW)* type
typesiglhs ::= var | con  // split off for syntax color; also Purescript allows constructors

quantifier ::= FORALLID vars+ DOT onl

simpletype ::= qcon? type | qcon (var)*

// 4.3.2
// Unlike Haskell, Purescript instances are "named to aid the readability of the
// generated Javascript"
// FIXME - this is not at all like plugin or Report
instancedecl ::= INSTANCEID typesigdecl (WHEREID idecls)?

idecls ::= idecl+
idecl ::= funlhs funrhs

// 4.4.3
funlhs ::= funid apat? (apat)*
funid ::= var   // Pulled out for syntax coloring


funrhs ::= EQUAL onl exp onl (WHEREID onl decls)* | gdrhs (WHEREID decls)*
gdrhs ::= guards EQUAL exp onl gdrhs?
guards ::= onl VERTICAL_BAR guard (COMMA guard)*
guard ::= pat LEFT_ARROW infixexp | LETID decls | infixexp



exp ::= infixexp COLON_COLON type | infixexp  // FIXME - why not type optional?
infixexp ::= lexp qop infixexp | MINUS infixexp | lexp  // Order matters!!
lexp ::= lambdaexp | letexp | ifexp | caseexp | doexp | fexp
lambdaexp ::= BACKSLASH apat+ RIGHT_ARROW exp
letexp ::= onl LETID decls onl INID exp
ifexp ::= onl IFID exp onl THENID exp onl ELSEID exp
caseexp ::= onl CASEID exp onl OFID onl alts
doexp ::= DOID onl stmts


alts ::= alt+
alt ::= pat RIGHT_ARROW exp (WHEREID decls)* onl | pat gdpat (WHEREID decls)*

gdpat ::= guards RIGHT_ARROW exp

stmts ::= stmt+
stmt ::= onl pat LEFT_ARROW exp onl | exp// Report has semi-colons req'd

pat ::= lpat
lpat ::= gcon apat+ | apat  // Order matters!
apat ::= var (ATSYM apat)* | gcon | qcon | literal | UNDERSCORE | LEFT_PAREN pat RIGHT_PAREN | LEFT_BRACE exp (COMMA exp)* RIGHT_BRACE

gcon ::= LEFT_BRACKET RIGHT_BRACKET | qcon




fexp ::= (fexp)* aexp+
// FIXME - this is deviating from Report
// FIXME the record initialization is dubious
aexp ::=  qvar DOT qvar | qvar | gcon | qcon | literal | onl LEFT_PAREN exp RIGHT_PAREN | LEFT_BRACKET exp RIGHT_BRACKET | LEFT_PAREN infixexp qop RIGHT_PAREN | LEFT_PAREN qop infixexp RIGHT_PAREN | DOLLAR exp | lambdaexp | LEFT_BRACE exp (COMMA exp)* RIGHT_BRACE


literal ::= INTEGER | DECIMAL | STRING



// 4.1.2
type ::= atype+ (RIGHT_ARROW onl type)?
//btype ::=  atype+                       // Match plugin, not Report

atype ::= gtycon | tyvar | LEFT_PAREN type RIGHT_PAREN | rec_constr | varop
// FIXME - LEFT_PAREN etc is Purescript only
tyvar ::= var | LEFT_PAREN var COLON_COLON type (VERTICAL_BAR var)* RIGHT_PAREN

// FIXME - qcon (plugin) vs qtycon (Report). Needed for type annotations
gtycon ::= qcon | LEFT_PAREN RIGHT_PAREN

// FIXME does this allow programs that won't actually compile?
// ie field labels mixed with normal constructors?
constrs ::= constr onl (VERTICAL_BAR constr onl)*
constr ::= con rec_constr | type

// FIXME get type and newtype to match in pattern
newtypeconstr ::= con type  | con rec_constr


// See constr1
rec_constr ::= onl LEFT_BRACE onl (onl fielddecl (onl COMMA onl fielddecl onl)*)? onl RIGHT_BRACE

fielddecl ::= vars COLON_COLON type //(type | atype)

vars ::= var (COMMA var)*

cname ::= var | con

// 3.2 Variables, Constructors, Operators, and Literals
var ::= VARID | LEFT_PAREN varsym RIGHT_PAREN    // Variables
varsym ::= BACKSLASH BACKSLASH | VARSYM
// FIXME - deviating from Report
qvar ::= qvarid | LEFT_PAREN qvarsym RIGHT_PAREN | UNDERSCORE

con ::= CONID    // Constructors  TODO - add consym
qcon ::= qconid | CONID

// FIXME double left arrow is same as less-than-equal-to
// FIXME minus being hit before VARSYM
qop ::= qvarop | MINUS | DOUBLE_LEFT_ARROW
qvarop ::= qvarsym | BACKTICK qvarid BACKTICK

//qvar_op ::= VARSYM  // TODO - not in Report

// 2.4 Identifiers and Operators
// VARID is token
// CONID is token
// Reserved words are tokens
//modid ::= (CONID DOT)+ CONID | CONID  // FIXME make it match Report, ie synonym
modid ::= (CONID DOT)* CONID | CONID  // FIXME make it match Report, ie synonym

// FIXME optional qualification here confuses its use, above. That is,
// hit several ways
qvarid ::= (modid DOT)* VARID
qconid ::= (CONID DOT)+ CONID  // TODO intellij-haskell is different than Report

qtycon ::= (modid DOT)* CONID
qvarsym ::= (modid DOT)* VARSYM


// Not in Report
dot_dot_parens ::= LEFT_PAREN DOT DOT RIGHT_PAREN
slash_slash_parens ::= LEFT_PAREN BACKSLASH BACKSLASH RIGHT_PAREN
private onl ::= NEWLINE*




//module_declaration ::= MODULE mod_id WHERE onl body
//
//private body ::= import_declarations top_declarations
//private import_declarations ::= import_declaration onl*
//private top_declarations ::= top_declaration onl*
//
//import_declaration ::= IMPORT mod_id  // TODO add parentheses for limiting
//
//mod_id ::= (CONID_ID DOT)+ CONID_ID | CONID_ID
//
//top_declaration ::= type_decl | data_decl | newtype_decl | class_decl | instance_decl | decl
//
//type_decl ::= TYPE  // TODO type synonyms work differently in purescript
//
//data_decl ::= DATA
//
//newtype_decl ::= NEWTYPE
//
//class_decl ::= CLASS
//
//instance_decl ::= INSTANCE
//
//decl ::= gendecl | funlhs funrhs
//
//gendecl ::= typesiglhs typesigrhs      // TODO add fixity decl
//
//typesiglhs ::= var_id
//
//typesigrhs ::= COLON_COLON // add fun type
//
//funlhs ::= var_id
//
//funrhs ::= EQUAL expression
//
//expression ::= first_line_expression (line_expression)+ last_line_expression | last_line_expression
//first_line_expression ::= general_id+ snl
//line_expression ::=  WHITE_SPACE* general_id+ snl
//last_line_expression ::= WHITE_SPACE* general_id+ snl //TODO is space necessary on one-line fun def?
//
//
//private onl ::= NEWLINE*
//private osnl ::= NEWLINE*
//snl ::= NEWLINE+
//
//con_id ::= CONID_ID
//
//var_id ::= VARID_ID
//qvar ::= var_id
//
//literal ::= STRING_LITERAL
//
//private general_id ::= qvar | DO | COLON_COLON | RIGHT_ARROW | LEFT_ARROW | QUOTE | literal | symbol_reserved_op
//
//private symbol_reserved_op ::= VERTICAL_BAR | EQUAL
//



private item_ ::= (KEY|SEPARATOR|VALUE|COMMENT|QUOTE)

property ::= (KEY? SEPARATOR VALUE?) | KEY {mixin="com.demo.psi.impl.PurescriptNamedElementImpl"
  implements="com.demo.psi.PurescriptNamedElement" methods=[getKey getValue getName setName getNameIdentifier]}


