{
parserClass="com.demo.parser.PurescriptParser"

extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

psiClassPrefix="Purescript"
psiImplClassSuffix="Impl"
psiPackage="com.demo.psi"
psiImplPackage="com.demo.psi.impl"

elementTypeHolderClass="com.demo.psi.PurescriptTypes"
elementTypeClass="com.demo.psi.PurescriptElementType"
tokenTypeClass="com.demo.psi.PurescriptTokenType"

psiImplUtilClass="com.demo.psi.impl.PurescriptPsiImplUtil"

elementTypePrefix="PS_"

tokens = [
line_comment = "regexp:--.*[\r\n]"       // ("--"[^\r\n]*)
EQUAL = "="          // Order matters. Needs to be before VARSYM since dupe
MODULE = "regexp:module[ ]+"
//LARGE = "regexp:[A-Z]"
//SMALL = "regexp:[a-z_]"
CONID = "regexp:[A-Z]{1}[A-Za-z_0-9]*" // Starts with cap
DOT = "."
WHERE = "regexp:where[ ]*[\r\n]+"
WHITE_SPACE = "regexp:[ ]+"      // This works without explicitly being in bnf(?!)
LEFT_PAREN = "("
RIGHT_PAREN = ")"
LEFT_BRACE = "{"
RIGHT_BRACE = "}"
COMMA = ","
VARID = "regexp:[a-z]{1}[A-Za-z_0-9]*" // Starts with lowercase
VARSYM = "regexp:[=><]+"
NEWLINE ="regexp:\n|\r|\r\n"
IMPORTID = "regexp:import[ ]+"  // TODO - Change all tokens with suffix?
TYPEID = "regexp:type[ ]+"
COLON_COLON = "regexp:::[ ]+"
DATAID = "regexp:data[ ]+"
VERTICAL_BAR = "regexp:\|[ ]+"  // FIXME - Space req'd?



]

}

module_declaration ::= MODULE modid onl (onl exports)? onl WHERE onl body

private body ::= impdecls topdecls


exports ::= LEFT_PAREN onl export (onl COMMA? onl export onl)* onl COMMA? onl RIGHT_PAREN
export ::= export1 | export2 | export3
export1 ::= qvar
//FIXME Constructor without parens not allowed in Purescript?
export2 ::= qcon onl (dot_dot_parens | LEFT_PAREN onl (cname onl (onl COMMA onl cname)*)? onl RIGHT_PAREN)?
export3 ::= MODULE modid


impdecls ::= (impdecl onl)*
impdecl ::= IMPORTID modid impspec*
// FIXME - Not sure line breaks supported in Purescript
impspec ::= LEFT_PAREN onl import (onl COMMA? onl import onl)* onl COMMA? onl RIGHT_PAREN
import ::= import1   // | import2
import1 ::= var
import2 ::= qcon onl (dot_dot_parens | LEFT_PAREN onl (cname onl (onl COMMA onl cname)*)? onl RIGHT_PAREN)?

topdecls ::= (topdecl onl)*
topdecl ::= typedecl | datadecl

typedecl ::= TYPEID simpletype EQUAL (type | rec_constr)

datadecl ::= DATAID simpletype onl EQUAL onl constrs

simpletype ::= qcon  // TODO what else is legal on lefthand side?

// 4.1.2
type ::= btype+   // FIXME I had to add the plus, not in Report
btype ::= (btype)* atype    // FIXME not sure why need parens
atype ::= gtycon

gtycon ::= qtycon   // TODO???

// FIXME does this allow programs that won't actually compile?
// ie field labels mixed with normal constructors?
constrs ::= constr onl (VERTICAL_BAR constr onl)*
constr ::= con rec_constr | type

rec_constr ::= onl LEFT_BRACE onl fielddecl (onl COMMA onl fielddecl onl)* onl RIGHT_BRACE

fielddecl ::= vars COLON_COLON type

vars ::= var (COMMA var)*      // FIXME - can you really have comma-separated vars?



cname ::= var | con



// 3.2 Variables, Constructors, Operators, and Literals
var ::= VARID | LEFT_PAREN VARSYM RIGHT_PAREN    // Variables
// FIXME? - this includes non-qualified in Report and intellij-haskell
qvar ::= qvarid | LEFT_PAREN qvarsym RIGHT_PAREN

con ::= CONID    // Constructors  TODO - add consym
qcon ::= qconid      // TODO Handle qualification


//qvar_op ::= VARSYM  // TODO - not in Report

// 2.4 Identifiers and Operators
// VARID is token
// CONID is token
// Reserved words are tokens
modid ::= (CONID DOT)+ CONID | CONID  // FIXME make it match Report, ie synonym

// FIXME optional qualification here confuses its use, above. That is,
// hit several ways
qvarid ::= (modid DOT)* VARID
qconid ::= (modid DOT)* CONID   // TODO intellij-haskell is different than Report

qtycon ::= (modid DOT)* CONID
qvarsym ::= (modid DOT)* VARSYM


// Not in Report
dot_dot_parens ::= LEFT_PAREN DOT DOT RIGHT_PAREN
private onl ::= NEWLINE*




//module_declaration ::= MODULE mod_id WHERE onl body
//
//private body ::= import_declarations top_declarations
//private import_declarations ::= import_declaration onl*
//private top_declarations ::= top_declaration onl*
//
//import_declaration ::= IMPORT mod_id  // TODO add parentheses for limiting
//
//mod_id ::= (CONID_ID DOT)+ CONID_ID | CONID_ID
//
//top_declaration ::= type_decl | data_decl | newtype_decl | class_decl | instance_decl | decl
//
//type_decl ::= TYPE  // TODO type synonyms work differently in purescript
//
//data_decl ::= DATA
//
//newtype_decl ::= NEWTYPE
//
//class_decl ::= CLASS
//
//instance_decl ::= INSTANCE
//
//decl ::= gendecl | funlhs funrhs
//
//gendecl ::= typesiglhs typesigrhs      // TODO add fixity decl
//
//typesiglhs ::= var_id
//
//typesigrhs ::= COLON_COLON // add fun type
//
//funlhs ::= var_id
//
//funrhs ::= EQUAL expression
//
//expression ::= first_line_expression (line_expression)+ last_line_expression | last_line_expression
//first_line_expression ::= general_id+ snl
//line_expression ::=  WHITE_SPACE* general_id+ snl
//last_line_expression ::= WHITE_SPACE* general_id+ snl //TODO is space necessary on one-line fun def?
//
//
//private onl ::= NEWLINE*
//private osnl ::= NEWLINE*
//snl ::= NEWLINE+
//
//con_id ::= CONID_ID
//
//var_id ::= VARID_ID
//qvar ::= var_id
//
//literal ::= STRING_LITERAL
//
//private general_id ::= qvar | DO | COLON_COLON | RIGHT_ARROW | LEFT_ARROW | QUOTE | literal | symbol_reserved_op
//
//private symbol_reserved_op ::= VERTICAL_BAR | EQUAL
//



private item_ ::= (KEY|SEPARATOR|VALUE|COMMENT|QUOTE)

property ::= (KEY? SEPARATOR VALUE?) | KEY {mixin="com.demo.psi.impl.PurescriptNamedElementImpl"
  implements="com.demo.psi.PurescriptNamedElement" methods=[getKey getValue getName setName getNameIdentifier]}


