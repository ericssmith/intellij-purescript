{
parserClass="com.demo.parser.PurescriptParser"

extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

psiClassPrefix="Purescript"
psiImplClassSuffix="Impl"
psiPackage="com.demo.psi"
psiImplPackage="com.demo.psi.impl"

elementTypeHolderClass="com.demo.psi.PurescriptTypes"
elementTypeClass="com.demo.psi.PurescriptElementType"
tokenTypeClass="com.demo.psi.PurescriptTokenType"

psiImplUtilClass="com.demo.psi.impl.PurescriptPsiImplUtil"

elementTypePrefix="PS_"

tokens = [
line_comment = "regexp:--.*[\r\n]"       // ("--"[^\r\n]*)
EQUAL = "="          // Order matters. Needs to be before VARSYM since dupe
DOUBLE_LEFT_ARROW = "<="   // Order matters.
DOUBLE_RIGHT_ARROW = "=>"
RIGHT_ARROW = "->"
MODULEID = "regexp:module[ ]+"
//LARGE = "regexp:[A-Z]"
//SMALL = "regexp:[a-z_]"
CONID = "regexp:[A-Z]{1}[A-Za-z_0-9]*" // Starts with cap
DOT = "."
WHEREID = "regexp:where[ ]*[\r\n]+"
WHITE_SPACE = "regexp:[ ]+"      // This works without explicitly being in bnf(?!)
LEFT_PAREN = "("
RIGHT_PAREN = ")"
LEFT_BRACE = "{"
RIGHT_BRACE = "}"
COMMA = ","
VARID = "regexp:[a-z]{1}[A-Za-z_0-9]*" // Starts with lowercase

NEWLINE ="regexp:\n|\r|\r\n"
IMPORTID = "regexp:import[ ]+"  // TODO - Change all tokens with suffix?
TYPEID = "regexp:type[ ]+"
COLON_COLON = "regexp:::[ ]+"
DATAID = "regexp:data[ ]+"
VERTICAL_BAR = "regexp:\|[ ]+"  // FIXME - Space req'd?
NEWTYPEID = "regexp:newtype[ ]+"
CLASSID = "regexp:class[ ]+"
FORALLID = "regexp:forall[ ]+"
INSTANCEID = "regexp:instance[ ]+"
INTEGER = "regexp:[0-9]+"
DECIMAL = "regexp:[0-9]+\.[0-9]+"
LETID = "regexp:let[ ]+"
INID = "regexp:in[ ]+"
IFID = "regexp:if[ ]+"
THENID = "regexp:then[ ]+"
ELSEID = "regexp:else[ ]+"

VARSYM = "regexp:[=><+@\|\\~!#$%\-\*\?\^]+" // List from plugin

]

}

module_declaration ::= MODULEID modid onl (onl exports)? onl WHEREID onl body

private body ::= impdecls topdecls


exports ::= LEFT_PAREN onl export (onl COMMA? onl export onl)* onl COMMA? onl RIGHT_PAREN
export ::= export1 | export2 | export3
export1 ::= qvar
//FIXME Constructor without parens not allowed in Purescript?
export2 ::= qcon onl (dot_dot_parens | LEFT_PAREN onl (cname onl (onl COMMA onl cname)*)? onl RIGHT_PAREN)?
export3 ::= MODULEID modid


impdecls ::= (impdecl onl)*
impdecl ::= IMPORTID modid impspec*
// FIXME - Not sure line breaks supported in Purescript
impspec ::= LEFT_PAREN onl import (onl COMMA? onl import onl)* onl COMMA? onl RIGHT_PAREN
import ::= import1   // | import2
import1 ::= var
import2 ::= qcon onl (dot_dot_parens | LEFT_PAREN onl (cname onl (onl COMMA onl cname)*)? onl RIGHT_PAREN)?

topdecls ::= (topdecl onl)*
topdecl ::= typedecl | datadecl | newtypedecl | classdecl | instancedecl | decls

typedecl ::= TYPEID simpletype EQUAL (type | rec_constr)

datadecl ::= DATAID simpletype onl EQUAL onl constrs

newtypedecl ::= NEWTYPEID simpletype EQUAL newtypeconstr

decls ::= decl*
decl ::= gendecl | funlhs EQUAL funrhs
gendecl ::= typesigdecl



// 4.3.1
// FIXME plugin has qualified con & var; Report does not
// FIXME Purescript has multiple params, in context as well
// Purescript has Nullary Type Class
classdecl ::= CLASSID (scontext DOUBLE_LEFT_ARROW)* con (var)*  (WHEREID cdecls)*
// TODO - add optional newlines
scontext ::= simpleclass | LEFT_PAREN simpleclass (COMMA simpleclass)* RIGHT_PAREN
simpleclass ::= qcon qvar+   //FIXME qcon+ in plugin
cdecls ::= (cdecl onl)+
cdecl ::= typesigdecl   // FIXME gendecl in Report, includes fixity, cdecl includes function def
context ::= LEFT_PAREN clazz (COMMA clazz)* RIGHT_PAREN
clazz ::= qcon vars+   // like plugin

// FIXME - for syntax coloring, will need to split off the name
typesigdecl ::= var COLON_COLON quantifier? (context DOUBLE_RIGHT_ARROW)* type

quantifier ::= FORALLID vars+ DOT

simpletype ::= qcon? type | qcon (var)*

// 4.3.2
// Unlike Haskell, Purescript instances are "named to aid the readability of the
// generated Javascript"
// FIXME - this is not at all like plugin or Report
instancedecl ::= INSTANCEID typesigdecl (WHEREID idecls)?

idecls ::= idecl+
idecl ::= funlhs EQUAL onl funrhs

// 4.4.3
funlhs ::= funid apat? (apat)*
funid ::= var   // Pulled out for syntax coloring
apat ::= var  // TODO - flesh out patterns


funrhs ::= exp
exp ::= infixexp
infixexp ::= lexp qop infixexp | lexp  // Order matters!!
lexp ::= onl LETID decls onl INID exp | onl IFID exp onl THENID exp onl ELSEID exp | fexp


// FIXME - this is modelled on btype below to fix infinite recursion
fexp ::= (fexp)* bexp      //  Report has [fexp] aexp, which recurses endlessly
bexp ::= aexp+
aexp ::= qvar | qcon | literal | LEFT_PAREN exp RIGHT_PAREN

literal ::= INTEGER | DECIMAL // FIXME replace



// 4.1.2
type ::= btype (RIGHT_ARROW type)?
btype ::=  atype+                       // Match plugin, not Report

atype ::= gtycon | var | LEFT_PAREN type RIGHT_PAREN

// FIXME - qcon (plugin) vs qtycon (Report). Needed for type annotations
gtycon ::= qcon

// FIXME does this allow programs that won't actually compile?
// ie field labels mixed with normal constructors?
constrs ::= constr onl (VERTICAL_BAR constr onl)*
constr ::= con rec_constr | type

// FIXME get type and newtype to match in pattern
newtypeconstr ::= con type  | con rec_constr


// See constr1
rec_constr ::= onl LEFT_BRACE onl (onl fielddecl (onl COMMA onl fielddecl onl)*)? onl RIGHT_BRACE

fielddecl ::= vars COLON_COLON type //(type | atype)

//vars ::= var (COMMA var)*      // FIXME - can you really have comma-separated vars?
vars ::= var

cname ::= var | con

// 3.2 Variables, Constructors, Operators, and Literals
var ::= VARID | LEFT_PAREN VARSYM RIGHT_PAREN    // Variables
// FIXME? - this includes non-qualified in Report and intellij-haskell
qvar ::= qvarid | LEFT_PAREN qvarsym RIGHT_PAREN

con ::= CONID    // Constructors  TODO - add consym
qcon ::= qconid | CONID

qop ::= qvarsym

//qvar_op ::= VARSYM  // TODO - not in Report

// 2.4 Identifiers and Operators
// VARID is token
// CONID is token
// Reserved words are tokens
//modid ::= (CONID DOT)+ CONID | CONID  // FIXME make it match Report, ie synonym
modid ::= (CONID DOT)* CONID | CONID  // FIXME make it match Report, ie synonym

// FIXME optional qualification here confuses its use, above. That is,
// hit several ways
qvarid ::= (modid DOT)* VARID
qconid ::= (CONID DOT)+ CONID  // TODO intellij-haskell is different than Report

qtycon ::= (modid DOT)* CONID
qvarsym ::= (modid DOT)* VARSYM


// Not in Report
dot_dot_parens ::= LEFT_PAREN DOT DOT RIGHT_PAREN
private onl ::= NEWLINE*




//module_declaration ::= MODULE mod_id WHERE onl body
//
//private body ::= import_declarations top_declarations
//private import_declarations ::= import_declaration onl*
//private top_declarations ::= top_declaration onl*
//
//import_declaration ::= IMPORT mod_id  // TODO add parentheses for limiting
//
//mod_id ::= (CONID_ID DOT)+ CONID_ID | CONID_ID
//
//top_declaration ::= type_decl | data_decl | newtype_decl | class_decl | instance_decl | decl
//
//type_decl ::= TYPE  // TODO type synonyms work differently in purescript
//
//data_decl ::= DATA
//
//newtype_decl ::= NEWTYPE
//
//class_decl ::= CLASS
//
//instance_decl ::= INSTANCE
//
//decl ::= gendecl | funlhs funrhs
//
//gendecl ::= typesiglhs typesigrhs      // TODO add fixity decl
//
//typesiglhs ::= var_id
//
//typesigrhs ::= COLON_COLON // add fun type
//
//funlhs ::= var_id
//
//funrhs ::= EQUAL expression
//
//expression ::= first_line_expression (line_expression)+ last_line_expression | last_line_expression
//first_line_expression ::= general_id+ snl
//line_expression ::=  WHITE_SPACE* general_id+ snl
//last_line_expression ::= WHITE_SPACE* general_id+ snl //TODO is space necessary on one-line fun def?
//
//
//private onl ::= NEWLINE*
//private osnl ::= NEWLINE*
//snl ::= NEWLINE+
//
//con_id ::= CONID_ID
//
//var_id ::= VARID_ID
//qvar ::= var_id
//
//literal ::= STRING_LITERAL
//
//private general_id ::= qvar | DO | COLON_COLON | RIGHT_ARROW | LEFT_ARROW | QUOTE | literal | symbol_reserved_op
//
//private symbol_reserved_op ::= VERTICAL_BAR | EQUAL
//



private item_ ::= (KEY|SEPARATOR|VALUE|COMMENT|QUOTE)

property ::= (KEY? SEPARATOR VALUE?) | KEY {mixin="com.demo.psi.impl.PurescriptNamedElementImpl"
  implements="com.demo.psi.PurescriptNamedElement" methods=[getKey getValue getName setName getNameIdentifier]}


